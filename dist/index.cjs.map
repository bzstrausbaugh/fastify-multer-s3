{"version":3,"sources":["../index.ts"],"sourcesContent":["import crypto from 'node:crypto';\nimport stream from 'node:stream';\nimport { fileTypeFromBuffer } from 'file-type';\nimport parallel from 'run-parallel';\nimport isSvg from 'is-svg';\n\nconst staticValue = (value) => {\n  return function (req, file, cb) {\n    cb(null, value);\n  };\n};\n\nvar defaultAcl = staticValue('private');\nvar defaultContentType = staticValue('application/octet-stream');\n\nvar defaultMetadata = staticValue(null);\nvar defaultCacheControl = staticValue(null);\nvar defaultShouldTransform = staticValue(false);\nvar defaultTransforms = [];\nvar defaultContentDisposition = staticValue(null);\nvar defaultStorageClass = staticValue('STANDARD');\nvar defaultSSE = staticValue(null);\nvar defaultSSEKMS = staticValue(null);\n\nconst defaultKey = (req, file, cb) => {\n  crypto.randomBytes(16, function (err, raw) {\n    cb(err, err ? undefined : raw.toString('hex'));\n  });\n};\n\nconst autoContentType = (req, file, cb) => {\n  file.stream.once('data', async (firstChunk) => {\n    var type = await fileTypeFromBuffer(firstChunk);\n    var mime;\n\n    if (type) {\n      mime = type.mime;\n    } else if (isSvg(firstChunk.toString())) {\n      mime = 'image/svg+xml';\n    } else {\n      mime = 'application/octet-stream';\n    }\n    var outStream = new stream.PassThrough();\n\n    outStream.write(firstChunk);\n    file.stream.pipe(outStream);\n\n    cb(null, mime, outStream);\n  });\n};\n\nfunction collect(storage, req, file, cb) {\n  parallel(\n    [\n      storage.getBucket.bind(storage, req, file),\n      storage.getKey.bind(storage, req, file),\n      storage.getAcl.bind(storage, req, file),\n      storage.getMetadata.bind(storage, req, file),\n      storage.getCacheControl.bind(storage, req, file),\n      storage.getShouldTransform.bind(storage, req, file),\n      storage.getContentDisposition.bind(storage, req, file),\n      storage.getStorageClass.bind(storage, req, file),\n      storage.getSSE.bind(storage, req, file),\n      storage.getSSEKMS.bind(storage, req, file),\n    ],\n    (err, values) => {\n      if (err) return cb(err);\n\n      storage.getContentType(\n        req,\n        file,\n        (err, contentType, replacementStream) => {\n          if (err) return cb(err);\n\n          cb.call(storage, null, {\n            bucket: values[0],\n            key: values[1],\n            acl: values[2],\n            metadata: values[3],\n            cacheControl: values[4],\n            shouldTransform: values[5],\n            contentDisposition: values[6],\n            storageClass: values[7],\n            contentType: contentType,\n            replacementStream: replacementStream,\n            serverSideEncryption: values[8],\n            sseKmsKeyId: values[9],\n          });\n        }\n      );\n    }\n  );\n}\n\nclass S3Storage {\n  s3;\n  getBucket;\n  getKey;\n  getAcl;\n  getContentType;\n  getMetadata;\n  getCacheControl;\n  getShouldTransform;\n  getTransforms;\n  getContentDisposition;\n  getStorageClass;\n  getSSE;\n  getSSEKMS;\n\n  constructor(opts) {\n    switch (typeof opts.s3) {\n      case 'object':\n        this.s3 = opts.s3;\n        break;\n      default:\n        throw new TypeError('Expected opts.s3 to be object');\n    }\n    switch (typeof opts.bucket) {\n      case 'function':\n        this.getBucket = opts.bucket;\n        break;\n      case 'string':\n        this.getBucket = staticValue(opts.bucket);\n        break;\n      case 'undefined':\n        throw new Error('bucket is required');\n      default:\n        throw new TypeError(\n          'Expected opts.bucket to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.key) {\n      case 'function':\n        this.getKey = opts.key;\n        break;\n      case 'undefined':\n        this.getKey = defaultKey;\n        break;\n      default:\n        throw new TypeError('Expected opts.key to be undefined or function');\n    }\n    switch (typeof opts.acl) {\n      case 'function':\n        this.getAcl = opts.acl;\n        break;\n      case 'string':\n        this.getAcl = staticValue(opts.acl);\n        break;\n      case 'undefined':\n        this.getAcl = defaultAcl;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.acl to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.contentType) {\n      case 'function':\n        this.getContentType = opts.contentType;\n        break;\n      case 'undefined':\n        this.getContentType = defaultContentType;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.contentType to be undefined or function'\n        );\n    }\n    switch (typeof opts.metadata) {\n      case 'function':\n        this.getMetadata = opts.metadata;\n        break;\n      case 'undefined':\n        this.getMetadata = defaultMetadata;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.metadata to be undefined or function'\n        );\n    }\n    switch (typeof opts.cacheControl) {\n      case 'function':\n        this.getCacheControl = opts.cacheControl;\n        break;\n      case 'string':\n        this.getCacheControl = staticValue(opts.cacheControl);\n        break;\n      case 'undefined':\n        this.getCacheControl = defaultCacheControl;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.cacheControl to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.shouldTransform) {\n      case 'function':\n        this.getShouldTransform = opts.shouldTransform;\n        break;\n      case 'boolean':\n        this.getShouldTransform = staticValue(opts.shouldTransform);\n        break;\n      case 'undefined':\n        this.getShouldTransform = defaultShouldTransform;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.shouldTransform to be undefined, boolean or function'\n        );\n    }\n    switch (typeof opts.transforms) {\n      case 'object':\n        this.getTransforms = opts.transforms;\n        break;\n      case 'undefined':\n        this.getTransforms = defaultTransforms;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.transforms to be undefined or object'\n        );\n    }\n    this.getTransforms.map(function (transform, i) {\n      switch (typeof transform.key) {\n        case 'function':\n          break;\n        case 'string':\n          transform.key = staticValue(transform.key);\n          break;\n        case 'undefined':\n          transform.key = defaultKey;\n          break;\n        default:\n          throw new TypeError(\n            'Expected opts.transform[].key to be unedefined, string or function'\n          );\n      }\n      switch (typeof transform.transform) {\n        case 'function':\n          break;\n        default:\n          throw new TypeError(\n            'Expected opts.transform[].transform to be function'\n          );\n      }\n      return transform;\n    });\n    switch (typeof opts.contentDisposition) {\n      case 'function':\n        this.getContentDisposition = opts.contentDisposition;\n        break;\n      case 'string':\n        this.getContentDisposition = staticValue(opts.contentDisposition);\n        break;\n      case 'undefined':\n        this.getContentDisposition = defaultContentDisposition;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.contentDisposition to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.storageClass) {\n      case 'function':\n        this.getStorageClass = opts.storageClass;\n        break;\n      case 'string':\n        this.getStorageClass = staticValue(opts.storageClass);\n        break;\n      case 'undefined':\n        this.getStorageClass = defaultStorageClass;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.storageClass to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.serverSideEncryption) {\n      case 'function':\n        this.getSSE = opts.serverSideEncryption;\n        break;\n      case 'string':\n        this.getSSE = staticValue(opts.serverSideEncryption);\n        break;\n      case 'undefined':\n        this.getSSE = defaultSSE;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.serverSideEncryption to be undefined, string or function'\n        );\n    }\n    switch (typeof opts.sseKmsKeyId) {\n      case 'function':\n        this.getSSEKMS = opts.sseKmsKeyId;\n        break;\n      case 'string':\n        this.getSSEKMS = staticValue(opts.sseKmsKeyId);\n        break;\n      case 'undefined':\n        this.getSSEKMS = defaultSSEKMS;\n        break;\n      default:\n        throw new TypeError(\n          'Expected opts.sseKmsKeyId to be undefined, string, or function'\n        );\n    }\n  }\n\n  _handleFile = (req, file, cb) => {\n    var storage = this;\n    collect(this, req, file, function (err, opts) {\n      if (err) return cb(err);\n\n      if (!opts.shouldTransform) {\n        storage.directUpload(opts, file, cb);\n      } else {\n        storage.transformUpload(opts, req, file, cb);\n      }\n    });\n  };\n\n  directUpload = (opts, file, cb) => {\n    var currentSize = 0;\n\n    var params = {\n      Bucket: opts.bucket,\n      Key: opts.key,\n      ACL: opts.acl,\n      CacheControl: opts.cacheControl,\n      ContentType: opts.contentType,\n      Metadata: opts.metadata,\n      StorageClass: opts.storageClass,\n      ServerSideEncryption: opts.serverSideEncryption,\n      SSEKMSKeyId: opts.sseKmsKeyId,\n      Body: opts.replacementStream || file.stream,\n    };\n\n    if (opts.contentDisposition) {\n      params['ContentDisposition'] = opts.contentDisposition;\n    }\n\n    var upload = this.s3.upload(params);\n\n    upload.on('httpUploadProgress', function (ev) {\n      if (ev.total) currentSize = ev.total;\n    });\n\n    upload.send(function (err, result) {\n      if (err) return cb(err);\n\n      cb(null, {\n        size: currentSize,\n        bucket: opts.bucket,\n        key: opts.key,\n        acl: opts.acl,\n        contentType: opts.contentType,\n        contentDisposition: opts.contentDisposition,\n        storageClass: opts.storageClass,\n        serverSideEncryption: opts.serverSideEncryption,\n        metadata: opts.metadata,\n        location: result.Location,\n        etag: result.ETag,\n        versionId: result.VersionId,\n      });\n    });\n  };\n\n  transformUpload = (opts, req, file, cb) => {\n    var storage = this;\n    var results: any[] = [];\n    parallel(\n      storage.getTransforms.map(function (transform) {\n        return transform.key.bind(storage, req, file);\n      }),\n      function (err, keys) {\n        if (err) return cb(err);\n\n        keys.forEach(function (key, i) {\n          var currentSize = 0;\n          storage.getTransforms[i].transform(req, file, function (err, piper) {\n            if (err) return cb(err);\n\n            var upload = storage.s3.upload({\n              Bucket: opts.bucket,\n              Key: key,\n              ACL: opts.acl,\n              CacheControl: opts.cacheControl,\n              ContentType: opts.contentType,\n              Metadata: opts.metadata,\n              StorageClass: opts.storageClass,\n              ServerSideEncryption: opts.serverSideEncryption,\n              SSEKMSKeyId: opts.sseKmsKeyId,\n              Body: (opts.replacementStream || file.stream).pipe(piper),\n            });\n\n            upload.on('httpUploadProgress', function (ev) {\n              if (ev.total) currentSize = ev.total;\n            });\n\n            upload.send(function (err, result) {\n              if (err) return cb(err);\n\n              results.push({\n                id: storage.getTransforms[i].id || i,\n                size: currentSize,\n                bucket: opts.bucket,\n                key: key,\n                acl: opts.acl,\n                contentType: opts.contentType,\n                contentDisposition: opts.contentDisposition,\n                storageClass: opts.storageClass,\n                serverSideEncryption: opts.serverSideEncryption,\n                metadata: opts.metadata,\n                location: result.Location,\n                etag: result.ETag,\n              });\n\n              if (results.length === keys.length) {\n                return cb(null, { transforms: results });\n              }\n            });\n          });\n        });\n      }\n    );\n  };\n\n  _removeFile = (req, file, cb) => {\n    this.s3.deleteObject({ Bucket: file.bucket, Key: file.key }, cb);\n  };\n}\n\nexport default function (opts) {\n  return new S3Storage(opts);\n}\n\nexport const AUTO_CONTENT_TYPE = autoContentType;\nexport const DEFAULT_CONTENT_TYPE = defaultContentType;\n"],"mappings":"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","names":["staticValue","value","req","file","cb","defaultAcl","defaultContentType","defaultMetadata","defaultCacheControl","defaultShouldTransform","defaultTransforms","defaultContentDisposition","defaultStorageClass","defaultSSE","defaultSSEKMS","defaultKey","crypto","randomBytes","err","raw","undefined","toString","autoContentType","stream","once","firstChunk","type","fileTypeFromBuffer","mime","isSvg","outStream","PassThrough","write","pipe","collect","storage","parallel","getBucket","bind","getKey","getAcl","getMetadata","getCacheControl","getShouldTransform","getContentDisposition","getStorageClass","getSSE","getSSEKMS","values","getContentType","contentType","replacementStream","call","bucket","key","acl","metadata","cacheControl","shouldTransform","contentDisposition","storageClass","serverSideEncryption","sseKmsKeyId","S3Storage","s3","getTransforms","constructor","opts","TypeError","Error","transforms","map","transform","i","_handleFile","directUpload","transformUpload","currentSize","params","Bucket","Key","ACL","CacheControl","ContentType","Metadata","StorageClass","ServerSideEncryption","SSEKMSKeyId","Body","upload","on","ev","total","send","result","size","location","Location","etag","ETag","versionId","VersionId","results","keys","forEach","piper","push","id","length","_removeFile","deleteObject","AUTO_CONTENT_TYPE","DEFAULT_CONTENT_TYPE"]}